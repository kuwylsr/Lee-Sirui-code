# 1143-最长公共子序列

## [题目](https://leetcode-cn.com/problems/longest-common-subsequence/)(难度中等)

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

~~~markdown
示例 1:

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
示例 2:

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
示例 3:

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
~~~

**提示:**
- 1 <= text1.length <= 1000
- 1 <= text2.length <= 1000
- 输入的字符串只含有小写英文字符。

### 算法知识点
1. 动态规划 (最经典双串 LCS 系列)

- 状态定义:
$f(i,j)$ 表示串A[:i]与串B[:j]的最长公共子序列的长度.

- 状态转移方程:
$$
f(i,j) = \left\{
    \begin{array}{rcl}
    f(i-1,j-1) + 1 && A[i]==B[j] \\
    max(f(i-1,j),f(i,j-1)) && A[i] \ne B[j]
    \end{array}
\right.
$$
注意, 当`A[i]`不等于`B[j]`时, 我们不需要取`f(i-1,j-1)`的值, 因为这个值可以由下一次`f(i,j-1)` 或 `f(i-1,j)`的状态转移得到.

- 初始化
因为, 状态转移方程中存在`i-1`以及`j-1`, 因此我们必须初始化第一行和第一列的所有值, 但如果我们的第一行或者第一列表示的是字符串的字一个字母与之对应的匹配的话, 那么初始化的工作将变得较为困难. 所以我们将矩阵拓展一行和一列, 来表示A或B是空串的情况, 空串与任何串的公共子序列长度都为0, 这样我们的初始化工作就完成了.

- 最后的返回值为

    ~~~ Java
    return dp[len1][len2];
    ~~~

