# 712-两个字符串的最小ASCII删除和

## [题目](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)(难度中等)

给定两个字符串`s1`, `s2`，找到使两个字符串相等所需删除字符的ASCII值的最小和。

~~~markdown
示例 1:

输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
示例 2:

输入: s1 = "delete", s2 = "leet"
输出: 403
解释: 在 "delete" 中删除 "dee" 字符串变成 "let"，
将 100[d]+101[e]+101[e] 加入总和。在 "leet" 中删除 "e" 将 101[e] 加入总和。
结束时，两个字符串都等于 "let"，结果即为 100+101+101+101 = 403 。
如果改为将两个字符串转换为 "lee" 或 "eet"，我们会得到 433 或 417 的结果，比答案更大。
~~~

**注意:**
- 0 < s1.length, s2.length <= 1000。
- 所有字符串中的字符ASCII值在[97, 122]之间。

### 算法知识点
1. 动态规划 (最经典双串 LCS 系列)

- 状态定义:
$f(i,j)$ 表示使得串A[:i]与串B[:j]相等,所需删除字符的ASCII值的最小和.

- 状态转移方程:
$$
f(i,j) = \left\{
    \begin{array}{rcl}
    f(i-1,j-1) && A[i] == B[j] \\
    min(f(i-1,j) + ASCII[i],f(i,j-1)) + ASCII[j] && A[i] \ne B[j]
    \end{array}
\right.
$$
注意, 当`A[i]`不等于`B[j]`时, 我们不需要取`f(i-1,j-1) + ASCII[i] + ASCII[j]`的值(即删除i也删除j), 因为这个值可以由下一次`f(i,j-1)` 或 `f(i-1,j)`的状态转移得到.

- 初始化
因为, 状态转移方程中存在`i-1`以及`j-1`, 因此我们必须初始化第一行和第一列的所有值, 但如果我们的第一行或者第一列表示的是字符串的字一个字母与之对应的匹配的话, 那么初始化的工作将变得较为困难. 所以我们将矩阵拓展一行和一列, 来表示A或B是空串的情况, 空串与任何串相等都需要删除另一个串的所有字符,我们将另一个串[:j]个字符的ASCII码进行累加, 这样我们的初始化工作就完成了.

- 最后的返回值为

    ~~~ Java
    return dp[len1][len2];
    ~~~

