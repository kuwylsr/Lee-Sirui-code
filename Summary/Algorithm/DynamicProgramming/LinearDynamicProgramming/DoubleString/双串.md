# 双串

有两个输入从串, 长度分别为m和n, 此时子问题需要用i,j两个变量表示, 分别代表第一个串和第二个串考虑的位置. `dp[i][j] := 第一个串考虑[0:i], 第二个串考虑[0:j]时原问题的解.`

较大规模的子问题只与常数个较小规模的子问题有关, 其中较小规模可能是 `i` 更小,或者是 `j` 更小,也可以它们同时变小.

其中一种最常见的状态转移形式: 推到 `dp[i][j]` 时, `dp[i][j]` 仅与 `dp[i-1][j]` , `dp[i][j-1]`, `dp[i-1][j-1]` 有关. 例如:

- 72 编辑距离
- 712 两个字符串的最小ASCII删除和

对于线性动态规划中双串 `dp[i][j]` 的问题, 状态的推到方向及推导公式如下:

![image1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/06/2-2-2.png)

如图所示, 蓝色部分的 `dp[i-1 ~ 0][j-1 ~ 0]` 均已经计算过, 但计算橙色的当前状态时, 仅用到 `dp[i-1][j], dp[i][j-1], dp[i-1][j-1]`, 即比i,j小的$O(1)$个子问题.

这种形式的线性DP的代码常见写法为:
~~~ Java
for i = 1..m
    for j = 1..n
        dp[i][j] = f(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
~~~
时间复杂度为 : $O(mn)$
空间复杂度为 : $O(mn)$

以上是$O(1)$转移的情况, 即计算 `dp[i][j]` 时, 虽然绿色部分的子问题均已经计算完, 但只需要用到 `dp[i-1][j], dp[i][j-1], dp[i-1][j-1]`. 也可能出现更高复杂度的转移, 类似单串中依赖比i小的$O(n)$ 个子问题的情况.