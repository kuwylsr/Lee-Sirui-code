# 873-最长的斐波那契子序列的长度

## [题目](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/)(难度中等)

如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：

- n >= 3
- 对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}

给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。

~~~markdown
示例 1：

输入: [1,2,3,4,5,6,7,8]
输出: 5
解释:
最长的斐波那契式子序列为：[1,2,3,5,8] 。
示例 2：

输入: [1,3,7,11,12,14,18]
输出: 3
解释:
最长的斐波那契式子序列有：
[1,11,12]，[3,11,14] 以及 [7,11,18] 。
~~~

### 算法知识点
1. 动态规划
此题与普通的单串问题(例如: 最长单调自增自序列等)不同的是, 它涉及状态时需要考虑最后两位的情况.

- 递归状态定义 : f(i,j) 表示以(i,j)结束的最长路径(最长的斐波那契式子序列). 其中, i和j为原数组的下标. 
    - 为什么需要两个状态呢, 因为斐波那契数列的递归形式中,要求前两个数的和要等于第三个数. 因此, 我们必须只知道两个数, 才能基于它算出第三个数.

- 递归方程:

$$
f(i,j) = f(k,i) + 1 , 其中k为(A[j]-A[i])的值在数组中的下标.
$$
因为题目中说到, 输入的数组是一个严格单调递增的数列,也就是说不会出现重复的数字,并且是自增的, 所以我们能找到的k按理说只有0个或者1个.

- 数组初始化 : 每个f(i,j)都初始化为2, 因为他们的长度均为2.