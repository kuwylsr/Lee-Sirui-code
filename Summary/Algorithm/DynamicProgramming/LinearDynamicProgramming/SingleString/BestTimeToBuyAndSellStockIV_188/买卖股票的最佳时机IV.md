# 188-买卖股票的最佳时机IV 

## [题目](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)(难度困难)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

~~~markdown
示例 1：

输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
示例 2：

输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
~~~

**提示:**
- 0 <= k <= 109
- 0 <= prices.length <= 1000
- 0 <= prices[i] <= 1000

### 算法知识点
1. 动态规划 (股票系列: dp[i][k][state] i 是时间，k 是次数，state 是状态)
在此题目中, 股票交易的次数也变成了一个变量, 限定为k. 因此我们需要在通过新加一个维度来表示目前实在第几次股票交易当中. 

- 状态定义:
$f(n,k,0)$ 表示在第n天交易完成后(第k次炒股过程当中), 手里没有股票的最大利润.
$f(n,k,1)$ 表示在第n天交易完成后(第k此炒股过程当中), 手里持有股票的最大利润.

- 状态转移方程:
$$
f(n,k,1) = max(f(n-1,k,1), f(n-1,k-1,0) - prices[i]) \\
f(n,k,0) = max(f(n-1,k,0), f(n-1,k,1) + prices[i])
$$

- **初始化**
这里是个人认为此题, 比较难的一个地方.
由于在递归方程中, 出现了 $i-1$ 和 $k-1$ 因此,我们需要初始化所有的 $i==0$ 以及 $k==0$.
    - 当初始化 $i==0$ 时, 有:

        ~~~ Java
        for(int x = 0 ; x < k ;x++){
            dp[0][x][1] = 0-prices[0];
            dp[0][x][0] = 0;
        }
        ~~~

    - 但当初始化 $k==0$ 时, 

        ~~~ Java
        for(int i = 0 ; i< len ;i++){
            dp[i][0][1] = 0-prices[i];
            //-------------------------------
            // 第一次炒股在第i天交易后, 手中没有股票的最大利润不好求.
            dp[i][0][0] = 0; //problem
            //-------------------------------
        } 
        ~~~

        我们无法确定, 遍历所有i时, $dp[i][0][0]$的值, 因为它的最大值和它是在什么时间被买入的有关, 初始化此值将变的异常费劲.

    为了解决上面阐述的初始化 $k==0$ 的问题, 我们可以将k维扩展成k+1维, 其中下标$[1,k]$代表k次股票交易, 而$k==0$代表第0次,相当于没有进行股票交易, 这样我们只需要初始化所有的$k==0$的状态值均为0之后, 从$k==1$开始遍历到$k==k$即可. 