# 410-分割数组的最大值

## [题目](https://leetcode-cn.com/problems/split-array-largest-sum/)(难度困难)

给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。

**注意:**
数组长度 n 满足以下条件:
- 1 ≤ n ≤ 1000
- 1 ≤ m ≤ min(50, n)

~~~markdown
示例:

输入:
nums = [7,2,5,10,8]
m = 2

输出:
18

解释:
一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
~~~

### 算法知识点
1. 动态规划 (带维度单串 dp[i][k]，i 为位置，k 为附加的维度)

- 状态定义:
f(i,k) 表示 将前i个数形成的数组A[:i]分成k份得到的各自子数组和的最大值的最小值.

- 递归方程:
$$
f(i,k) = min_{k-1 \le j < i}(min(dp[j][k-1], sum(j+1,i)))
$$
其中, sum(j+1,i)表示的是数组 A[j+1] 到 A[i]的和.

2. 二分查找 + 贪心

- **白话题目**
有一个数组,你要分割成m份, 每一份都有一个和, 这些和中存在的最大值. 而你需要找出一个分割方式使得这个最大值最小. 假如我们设这个值为x.

- **二分查找的思路**
即我们要在一个范围内, 查找我们想要的这个值x

- **二分查找的范围**
这个x的取值范围:
最大为 : 整个数组的总和
最小为 : 整个数组中的最大值
所以, 二分查找的范围是 [max(nums), sum(nums)]

- **进行二分查找**
二分查找本质上就是每次测试范围的中点是需要变大还是需要变小, 从而缩小搜索的范围.

- **如何看这个中点值是大了还是小了**
每次:
假设这个中点 `mid` 就是 "每个数组和中的最大值"的最小值.
那么 `每个数组和必定 <= mid`.
因此, 你用这个值来对数组进行从头分割, 一旦`当前的数组和 > mid`, 就结束该分组,开启一个新的分组.
    - 如果, 你用这个mid值分割出来的数组的数量比 m 多, 则说明mid值定小了, 所以需要在右半查找

    - 如果, 你用这个mid值分割出来的数组的数量比 m 少, 则说明mid值定大了, 所以需要在左半查找

- **二分查找的结束**
当你的查找范围内只剩下一个数的时候, 结束二分查找. left即为最终结果.


- **特别注意**
如果 `分割出来的数组个数` 等于m, 会怎么样?
如果 `分割出来的数组个数` 等于m, 但此时[left,right]范围内仍然不止有一个数, 范围还是应该继续收敛的, 且取左半继续收敛, 目的是让我们能最终得到一个确切的值, 这个值恰好就是取得了最大值的那个数组的和.

[参考题解](https://leetcode-cn.com/problems/split-array-largest-sum/solution/bai-hua-er-fen-cha-zhao-by-xiao-yan-gou/)