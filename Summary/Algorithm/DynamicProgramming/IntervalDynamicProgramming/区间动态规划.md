# 区间动态规划简介

区间DP 是状态的定义和转移都与区间有关, 其中区间用两个端点表示.

状态定义 `dp[i][j] = [i..j] 上原问题的解`. i变大,j变小都可以得到更小规模的子问题.

对于单串上的问题, 我们可以对比一下线性动态规划和区间动态规划. 线性动态规划, 一般是定义 `dp[i]`, 表示考虑到前i个元素原问题的解, i变i即得到更小规模的子问题, 推到状态的时候从前往后, 即i从小到大推导.

而区间动态规划, 一般是定义 `dp[i][j]`, 表示考虑 [i..j] 范围内的元素, 原问题的解增加i, 减小j都可以得到更小规模的子问题. 推到状态一般是按照区间长度从短到长推的.

区间动态规划的状态设计, 状态转移都与线性动态规划有明显区别, 但是由于这两种方法都经常用在单串问题上, 拿到一个单串问题时, 往往不能快速地判断到底是用线性动态规划还是区间动态规划, 这也是区间动态规划的难点之一.

**状态转移, 推到状态 dp[i][j]时, 有两种情况**

1. **dp[i][j]仅与常数个更小规模子问题有关**
    一般是与 `dp[i+1][j], dp[i][j-1], dp[i+1][j-1]` 有关. 即
    $$
    dp[i][j] = f(dp[i+1][j], dp[i][j-1], dp[i+1][j-1])
    $$

    示意图如下:
    ![image1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/06/4-1-1.png)

    代码常见写法如下:
    ~~~ Java
    for len = 1..n 
        for i = 1 .. len
            j = i + len - 1
            dp[i][j] = max(dp[i][j], f(dp[i+1][j], dp[i][j-1], dp[i+1][j-1]))
    ~~~
    其时间复杂度和空间复杂度均为 : $O(n^2)$

2. **dp[i][j]与O(n)个更小规模子问题有关**
    一般是枚举 [i,j] 的分割点, 将区间分为 [i,k] 和 [k+1,j], 对每个k分别求解(下面公式的f), 再汇总(下面公式的g).
    $$
    dp[i][j] = g(f(dp[i][k], dp[k+1][j])) 其中 k = i,...,j-1 .
    $$

    示意图如下:
    ![image2](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/06/4-1-2.png)

    代码常见写法如下(以下代码以f为max为例)
    ~~~Java
    for len = 1..n
        for i = 1..len
            j = i + len - 1
            for k = i..j
                dp[i][j] = max(dp[i][j], f(dp[i][k], dp[k][j]))
    ~~~
    时间复杂度可以达到 $O(n^3)$, 空间复杂度还是 $O(n^2)$

# 总结
区间动态规划一般用在单穿问题上, 以区间 [i.j] 为单位思考状态的设计和转移. 它与线性动态规划在状态设计和状态转移上都有明显的不同, 但由于这两种方法都经常用在单串问题上, 导致我们拿到一个单串的问题时, 经常不能快速反映出应该用哪种方法. 这是区间动态规划的难点之一, 但是这个难点也是好解决的, 就是做一定数量的练习题, 因为区间动态规划的题目比线性动态规划少很多, 并且区间动态规划的状态设计和转移都比较朴素,变化比线性动态规划少很多, 所以通过不多的题目数量就可以把区间动态规划常见的方法和变化看个大概了.