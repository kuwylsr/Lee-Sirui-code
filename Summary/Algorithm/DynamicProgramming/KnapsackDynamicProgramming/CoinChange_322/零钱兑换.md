# 322-零钱兑换

## [题目](https://leetcode-cn.com/problems/coin-change/)(难度中等)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

~~~markdown
示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0
示例 4：

输入：coins = [1], amount = 1
输出：1
示例 5：

输入：coins = [1], amount = 2
输出：2
~~~

**提示:**
- 1 <= coins.length <= 12
- 1 <= coins[i] <= 231 - 1
- 0 <= amount <= 104

### 算法知识点
1. 动态规划 完全背包问题
该题, 类似与完全背包问题.

- 状态定义
f(i,j) 表示用coins[:i] 来凑总额j所需要的最少金币的数量.

- 状态转移方程
$$
f(i,j) = \left\{
    \begin{array}{rcl}
        f(i-1,j) && coins[i] > j \\
        min(f(i,j-coins[i])+1, f(i-1,j)) && coins[i] \le j
    \end{array}
\right.
$$
需要注意的是, 由于此题的要求刚好等于目标金额, 因此,当金额总和不等于目标金额时, 我们将其设置为-1. 在状态转移之前需要进行相应的判断.

2. 空间简化
- 状态转移方程
$$
f(j) = min(f(j), f(j-coins[i])+1)
$$
(需要特别注意j从小到大遍历)

3. 答案解法的动态规划

- 状态定义
f(i) 表示组成金额i所需最少的硬币数量

- 状态转移方程
$$
f(i) = min_{0 \le j \le n-1}(f(i-coins[j])+1)
$$
我们可以发现, 这个解法非常类似与前面空间简化之后的版本, 但是区别在于这个是可以解释的,并且外层循环是遍历所有的目标金额, 内层循环是遍历所有的硬币.(这与空间简化版本是相反的)

4. 特殊考虑: 如果硬币的选择不能重复选取
那么其空间简化版本的状态转移方程为:
$$
f(j) = min(f(j), f(j-coins[i])+1)
$$
(需要特别注意j从大到小遍历).

**注意:**
通过实际的编写程序, 发现空间简化版本的编写更为容易, 尤其是在动态规划数组的初始化阶段.
!!! 推荐直接按照 01背包 或者 完全背包的 **空间简化模板进行编写**