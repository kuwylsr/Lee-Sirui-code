# 背包动态规划

背包问题(Knapsack problem)是一种组合优化的NP完全问题.

背包问题的描述为 : 给定一组物品, 每种物品都有自己的重量和价格, 在限定的总重量内, 我们如何选择, 才能使得物品的总价格最高.

- 有n中物品,  物品i的体积为 $v_i$, 价值为 $w_i$, 有一个体积限制 V .如何选择物品使得总体积不超过V, 并使得总价值最大.

这是背包问题最基础的描述, 再往下还可以把背包问题分成几大类, 其中比较基础的是3中 : 01背包, 完全背包, 多重背包.

## 01背包问题

01背包的问题描述:

- 有n种物品, 物品i的体积为 $w_i$, 价值为 $v_i$ ,有一个体积限制 V. 每种物品只有1个, 只有选或者不选两选择, 而没有选几个的问题, 此问题称为01背包问题.

状态定义 :

- $f(i,j)$ 表示前i个物品和背包的容量j, 所能取得的最大价值.

状态转移方程 :

$$
f(i,j) = \left\{
    \begin{array}{rcl}
        f(i-1,j) && w[i] \ge j \\
        max(f(i-1,j-w[i]) + v[i], f(i-1,j)) && w[i] \le j
    \end{array}
\right.
$$
状态转移方式有两种, 一种是放入(如果可以), 一种是不放入.

**衍生问题: 要求背包必须放满**
这时, 我们可以用-1来表示没有装满的情况.

**01背包问题的空间优化**
我们不难发现, 在01背包问题的状态转移方程中, 第i维只与第i-1维有关系. 因此我们可以通过滚动数组的方式进行降维.

假设状态只有1行, 即 f(j) 表示使用j大小的空间所能取得到的最大价值, 在推第i行的时候, dp数组中存的是第i-1行的信息.

看状态的两个转移方向, 第一个是 `f(i-1,j)` , 这刚好就是当前状态在j位置所保存的数据, 因此不同动; 而对于 `f(i-1, j-w[i]) + v[i]` ,这里用到的是第i-1行的 `f(j-w[i])` ,但如果我们按照正常的j从0到V推导的话, 计算 f(j) 的时候, f(j-w[i]) 保存的已经是第i行的信息了. 因此我们需要将j从大到小进行遍历.

01背包的最终形态
$$
f(j) = max(f(j), f(j-w[i]) + v[i])
$$
(j从大到小推导).

## 完全背包问题

完全背包问题的描述 : 

有n种物品, 物品i的体积为$w_i$, 价值为 $v_i$ ,有一个体积限制 V. 每种物品有无限个, 此问题称为完全背包问题. 
但是由于有体积限制, 因此实际取的数量也是有限制的, 每个物品其实最多只能取 V/v[i] 个.

状态定义(同01背包)

- f(i,j) 表示前i个物品和背包的容量j, 所能取得的最大价值.

状态转移方程:

$$
f(i,j) = \left\{
    \begin{array}{rcl}
        f(i-1,j) && w[i] \ge j \\
        max(f(i,j-w[i]) + v[i], f(i-1,j)) && w[i] \le j
    \end{array}
\right.
$$
与01背包问题唯一的区别在于, 完全背包问题选择了物品i之后, 仍可以继续选择.

**完全背包问题的空间优化**
由于在完全背包问题中, 推到第i行的f(j)时, 用到的同样是第i行的f(j-w[i]),因此我们必须将j从小到大进行遍历.

完全背包的最终形式:
$$
f(j) = max(f(j), f(j-w[i]) + v[i])
$$
(j从小到大推导).

## 多重背包问题

多重背包问题的问题描述 : 

有n种物品, 物品j的体积为$w_i$, 价值为 $v_i$ ,有一个体积限制 V. 每种物品还有一个 $c_i$ 表示每种物品的个数, 此问题称为多重背包问题.

多重背包问题相对较难, 在此不在详细说明.

# 背包动态规划问题的分析步骤

前面我们说过, 背包动态规划问题可以大致上可以分为三种 : 01背包, 完全背包, 多重背包.

实际问题会把背包问题做各种包装, 而不会把问题描述的这么直白, 背包的问题常见的有三种, 第一个是求最值, 这是背包的原始问题, 第二个是体积要取到背包容量的最值, 第三个是求方案数, 即组合问题.

**背包问题的分析步骤:**

1. 分析是否为背包问题

2. 是背包问题中三种问法的哪一种

3. 是0-1背包问题还是完全背包问题. 也就是题目给的 nums 数组中的元素是否可以重复使用.

4. 如果是组合问题, 即求方案数, 是否需要考虑元素之间的顺序. 需要考虑顺序有顺序的解法, 不需要考虑顺序又有对应的解法, 需要注意.