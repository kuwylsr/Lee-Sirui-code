# 93-复原IP地址

## [题目](https://leetcode-cn.com/problems/restore-ip-addresses/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)(难度中等)

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

~~~markdown
示例 1：

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
示例 2：

输入：s = "0000"
输出：["0.0.0.0"]
示例 3：

输入：s = "1111"
输出：["1.1.1.1"]
示例 4：

输入：s = "010010"
输出：["0.10.0.10","0.100.1.0"]
示例 5：

输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
~~~

**提示:**
- 0 <= s.length <= 3000
- s 仅由数字组成

### 算法知识点
1. 回溯法（深度搜索）

- 首先, 我们必须先明确回溯函数所需要的参数

    ~~~ Java 
    /**
     * 
     * @param s 数字字符串
     * @param index 当前开始形成某个segment的其实下标
     * @param tmpResult 存储当前结果的数组(长度为4)
     * @param segmentNum 当前要形成的segment的序号(第几个segment)
     */
    private void backTrace(String s, int index, String[] tmpResult, int segmentNum);
    ~~~

- 回溯函数的递归终止条件
    - 当形成了4个segment
    当形成了4个segment,并且用完了4个字符,则结果符合要求,变换格式并将其写入结果集.
    - 当用完了数字字符串的所有字符
    - 当出现前导0, 并且遍历完了该前导0的所有情况.(因为前导0的存在, 它能形成的segment只有一种, 不需要在进行回溯)

- 回溯的编写
因为此题,回溯的意思就是在此前的segment的基础上再往后添加字符形成新的segment, 因此只需要仅需遍历for循环即可, 然后重新覆盖之前的tmpResult.