# 437-路径总和

## [题目](https://leetcode-cn.com/problems/path-sum-iii/)(难度中等)

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

~~~markdown
示例：

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
~~~

### 算法知识点
1. 本人算法: 暴力遍历 + 找出路径
首先,将所有树的节点存起来, 然后依次遍历节点,以当前的节点作为当前根节点,找到目标路径和为目标值的路径数量,进行累加.

2. 双递归
递归的一个重要思想就是两部分：
    - 找到最简单的子问题求解
    - 其他问题不考虑内在细节，只考虑整体逻辑

    双递归的思想和第一种方法一样, 第一个递归来遍历所有树节点, 第二个递归来以当前节点为根节点, 求解路径.

3. 前缀和
这道题用到了一个概念，叫前缀和。就是到达当前元素的路径上，之前所有元素的和。
前缀和怎么应用呢？
如果两个数的前缀总和是相同的，那么这些节点之间的元素总和为零。进一步扩展相同的想法，如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target。
因为本题中的路径是一棵树，从根往任一节点的路径上(不走回头路)，有且仅有一条路径，因为不存在环。(如果存在环，前缀和就不能用了，需要改造算法)
抵达当前节点(即B节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和currSum-target的节点(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和currSum-target的节点的数量。然后递归进入左右子树。
左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。


### 编程知识点
1. Map中的 getOrDefault(Object key, V defaultValue) 方法

