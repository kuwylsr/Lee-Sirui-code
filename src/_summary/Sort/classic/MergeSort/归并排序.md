# 归并排序
---

归并排序 (Merge Sort) 是建立在归并操作上的一种有效的排序算法. 该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用.

作为一种典型的分而治之西乡的算法应用, 归并排序的实现有两种办法:

- 自上而下的递归(所有递归的方法都可以用迭代重写, 所以就有了第2种方法);

- 自下而上的迭代;

在 <数据结构预算法JavaScript描述> 中,作者给出了自下而上的方法. 但是对于递归法,作业却认为:

> However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 
然而,在 JavaScript 中这种方式不太可行, 因为这个算法的递归深度对它来讲太深了.

(意思是 JavaScript 编译器内存太小, 递归太深容易造成内存溢出吗?)

和选择排序一样,归并排序的性能不受输入数据的影响, 但表现比选择排序好得多, 因为始终都是 $O(logN)$ 的时间复杂度. 代价是需要额外的内存空间.

## 1. 算法步骤

1. 申请空间,使其大小为两个已经排序序列之和, 该空间同来存放合并后的序列;
 
2. 设定两个指针, 最初位置分别为两个已经排序序列的起始位置;

3. 比较两个指针所指向的元素, 选择相对小的元素放入到合并空间, 并移动指针到下一个位置.

4. 重复步骤3知道某一指针达到序列尾;

5. 将另一序列剩下的所有元素直接复制到合并序列尾.

## 2. 动图演示

![image1](https://github.com/kuwylsr/JS-Sorting-Algorithm/raw/master/res/mergeSort.gif)

## 3. 时间复杂度

- 平均时间复杂度 : $O(NlogN)$

- 最好情况 :　$O(NlogN)$

- 最坏情况 : 　$O(NlogN)$

## 4. 空间复杂度

- 空间复杂度 :　$O(N)$

- Out-place

## 5. 稳定性

- 稳定