# 3-无重复字符的最长子串

## [题目](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)(难度中等)
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

```markdown
示例1：
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例2：
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例3：
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

### 算法知识点
1. 注意几乎所有最xx子串问题的算法，都是通过**少遍历一些子串**来降低时间复杂度的。
1. 本人初次采用的是通过更改起点i,来遍历每个子串（“伪暴力求解”）（因为当以i为起点的某个字符串存在冲突时，就右移i重新遍历，并没有遍历所有的子字符串）,在进行字符冲突判定的时候采用hashset加快查找,但整体上算法的时间复杂度仍为O($n^2$)
2. 答案中较为快速的方法是通过滑动窗口来进行优化，其思想为如果从i到j-1之间都没有冲突的字符，那么只需要s[j]对应的字符是否在字符串$s_{ij}$中，即没必要每次遇到冲突，都让i向右移然后从头遍历。
3. 进一步的优化策略，可以考虑用map来存储字符以及它所对应的下标，当出现冲突时，就可以直接定位冲突元素的下标，然后让i直接跳到冲突元素的下一个元素开始执行。
4. 进一步进一步的优化策略，可以用一个足够大的数组（记得要初始化为0）来记录字符及其下标，这样就可以直接访问数组来代替map。

### 编程知识点
1. 对于C++，基本数据类型（如int等）可以通过如下方式直接初始化：
	```C++
	int a(0) //定义int型的a，并初始化为0
	```
2. 对于C++中的字典map来说，用insert来进行插入，如果map已存在与插入键值相同的键值对，则直接忽略，不会像java一样对其进行覆盖，如果想覆盖，可以使用如下形式：
	```C++
	charToIndex[i] = j; //insert方式插入数据，重复的key会直接被放弃，而不是进行覆盖（这一点与Java不同）
	```
3. 对于[C++数组的定义](https://blog.csdn.net/zhanshen112/article/details/84956950)通过如下形式：
	```C++
	int index[128];
	```
	但这种形式，会对数组中的元素进行随机赋值，如果想要全部初始化为0:
	```C++
	int index[128]={};
	```