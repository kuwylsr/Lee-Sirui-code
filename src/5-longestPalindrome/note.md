# 5-最长回文子串

## [题目](https://leetcode-cn.com/problems/longest-palindromic-substring/)（难度中等） 

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
```markdown
示例 1：
输入: "babad"
输出: "bab"
（注意: "aba" 也是一个有效答案。）

示例 2：
输入: "cbbd"
输出: "bb"
```

### **算法知识**
1. [参考答案1](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/)  
[参考答案2](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)
[参考答案3](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/)

2. 首先，我们能想到的就是 **暴力枚举(Brute Force)** 方法，通过枚举所有长度大于等于2的子串(substring)，来一次判断他们是否是回文。简单地优化，我们可以在具体实现的时候，只针对大于“当前得到的最长回文子串长度”的子串进行遍历验证。
- **时间复杂度** ：$O(n^3)$ ，假设 n 是输入字符串的长度，则 <u> $\binom{n}{2} = \frac{n(n-1)}{2}$ 为此类子字符串(不包括字符本身是回文的一般解法)的总数 </u>。因为验证每个子字符串需要 $O(n)$ 的时间，所以运行时间复杂度是 $O(n^3)$ 。
- **空间复杂度** ：$O(1)$

3. 温习[动态规划(Dynamic Programming)](https://blog.csdn.net/zw6161080123/article/details/80639932)

Dyanmic Programming is just a fancy way to say 'remembering stuff to save time later'. 按照定义，动态规划就是把一个大问题拆解成一堆小问题，但问题能否用动态规划解决的关键在于这些“小问题”会不会被重复调用。

能采用动态规划求解问题的一般要具有的3个性质：
- **最优化原理**：如果问题的最优解所包含的子问题的解也是最优的，就成个问题具有最优子结构，即满足最优化原理。

- **无后效性**：某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，至于当前状态有关。

- **有重叠子问题**：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划的算法同其他算法相比就不具备优势）

动态规划所处理的问题是一个 <font color=red>多阶段决策问题</font> ，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是寻求最优的活动路线）。动态规划的设计都有着一定的模式，一般要经历一下几个步骤：
(1) **<font color=red>划分阶段</font>** : 按照问题的时间或空间特征，把问题分为若干阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
(2) **<font color=red>确定状态和状态变量</font>** : 将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
(3) **<font color=red>确定决策并写出状态转移方程</font>** : 因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可以写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
(4) **<font color=red>寻找边界条件</font>** : 给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。
递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，<font color=red>不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</font>
确定了动态规划的这三要素，<font color=red>整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等）</font>，填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

简化的步骤：
(1)分析最优解的性质，并刻画其结构特征 
(2)递归定义最优解
(3)以自底向上或者自顶向下的记忆化方式（备忘录法）计算出最优值
(4)根据计算最优值时得到的信息，构造问题的最优解

4. 我们可以将最长回文子串问题，“大致”的转化为 **最长公共子串问题** 。因为更具回文串的定义，正着读和反着读是一样的，因此直觉告诉我们可以通过将原本的字符串倒置，然后求得最长的公共子串就可以了。 
但为什么说是“大致”可以转化呢？因为比如字符串 `"abc123cba"` 的反向字符串为 `"abc321cba"` ,但我们不难发现，子串 `"abc"` 并不是最长回文子串。因此，我们还需要判断该目标“回文”字符串倒置前的下标和倒置后的下标是不是匹配。（具体地，倒置后的下标对应的倒置前的位置应该于对应的相等字符下标相距公共子串长度的距离）
关于求最长公共子串（不是公共子序列），有很多方法，这里用动态规划的方法，整体思想就是，申请一个二维的数组初始化为0，然后判断对应的字符是否相等，相等的话有 `arr[i][j] = arr[i-1][j-1] + 1` ，当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 `arr[i][j] = 1` 。其中， `arr[i][j]` 保存的就是（在原串中以 i 结尾的，在反串中以 j 结尾的）公共子串的长度。
递推公式为：
$P(i,j)$ 的含义为：在原串中以下标 i 结尾的，在反串中以下标 j 结尾的最长公共子串的长度。
	$$
	P(i,j)=
	\begin{cases}
	1, (i=0 or j=0) and 字符相等 \\
	P(i-1,j-1) + 1, 字符相等 \\
	0, 字符不相等
	\end{cases}
	$$

5. 这道题最经典的解法就是直接利用 **动态规划** 来解决问题。为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。
我们可以对 P(i,j) 进行如下定义：
$P(i,j)$ 的含义为：从下标 i 到下标 j 的子串是否为回文子串。
	$$
	P(i,j)=
	\begin{cases}
	true, 如果子串 S_i...S_j 是回文子串 \\
	false, 其他情况
	\end{cases}
	$$
因此，
$$P(i,j) = (P(i+1,j-1) and S_i==S_j)$$
- 时间复杂度： $O(n^2)$ 
- 空间复杂度： $O(n^2)$ ，该方法使用 $O(n^2)$ 的空间来存储表

6. **中心扩散法**

### **编程知识**
1. C++ 函数传参 加 &？

2. C++ 取字符串 string 中的某个字符的方式
	```C++
	string test = "abc";
	test[0] == 'a';
	test.at(0) == 'a';
	```

3. C++ 求数组的长度
	```C++
	int arr[5] = {};
	int len = size_of(arr)/size_of(arr[0]);
	```

4. C++ 动态二维数组
	```C++
	int init = 0; //二维数组初始化值
	int row = 4; //行数
	int col = 5; //列数
	vector<int> temp(row,init);
	vector<vector<int>> arr(col，temp);
	```

5. C++ [集合反转](https://www.cnblogs.com/yuanch2019/p/11591995.html)
导入都文件 <algorthm> 中的函数包 reverse()