# 538-把二叉搜索树转换为累加树

## [题目](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)(难度简单)

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。           
```markdown
例如：

输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13

```

### 算法知识点
1. [二叉搜索树](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855?fr=aladdin)的特点。

2. 学会[三种树的遍历方式](https://blog.csdn.net/czy47/article/details/81254984)，前序遍历，中序遍历以及后序遍历。(分别用递归和非递归编程)
    - 在这里思考一个问题：深度优先搜索和树的三种遍历方式有什么关系？本人觉得树的前中后序遍历都属于深度优先搜索，只是访问节点的时机不一样。。。（不知道在不在理）

3. 此题利用二叉搜索树的特点，只需要反向的使用中序遍历(左 -> 根 -> 右), 变为(右 -> 根 -> 左)即可解决问题。

4. 此题也可采用 反向的 `Morris` 中序遍历方法。(此方法在501题有介绍)

5. 复杂度分析
    - 时间复杂度：$O(N)$ 其中 $n$ 是二叉搜索树的节点数。每一个节点恰好被遍历一次。
    - 空间复杂度：$O(N)$ 为递归过程中栈的开销，平均情况下为 $O(log N)$，最坏情况下树呈现链状，为 $O(N)$

### 编程知识点
1. 学会C++中的 [pair](https://blog.csdn.net/weixin_42825576/article/details/81571419)