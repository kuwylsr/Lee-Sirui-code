# 416-分割等和子集

## [题目](https://leetcode-cn.com/problems/partition-equal-subset-sum/)(难度中等)

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**注意**:
1. 每个数组中的元素不会超过 100
2. 数组的大小不会超过 200

~~~markdown
示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
 

示例 2:

输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集
~~~

### 算法知识点
1. 动态规划,类似于 0-1背包问题
- 递归方程
$$
d p[i][j]=\left\{\begin{array}{ll}
d p[i-1][j] \mid d p[i-1][j-n u m s[i]], & j \geq \text {nums}[i] \\
d p[i-1][j], & j<\text {nums}[i]
\end{array}\right.
$$
其中,i为数的index, j为数组总和的一半.

**注意** : 需要额外注意的是,如果数组总和的一半为奇数,则直接返回false.

- **边界**初始化
dp[0][j] 必须要初始化
dp[i][0] 我们也可以得到,但不是必须

2. 极简空间的动态规划
可以发现在计算 $dp$ 的过程中，每一行的 $dp$ 值都只与上一行的 dpdp 值有关，因此只需要一个一维数组即可将空间复杂度降到 $O(target)$。此时的转移方程为：
$$
d p[j]=d p[j] \mid d p[j-\text {nums}[i]]
$$
且需要注意的是第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 $dp$ 值，那么在计算 $dp[j]$ 值的时候，$dp[j−nums[i]]$ 已经是被更新过的状态，不再是上一行的 $dp$ 值。
**边界**:

### 编程知识点
1. java不同类型数组的初始化
- boolean 类型的数组
    ~~~java
    boolean[] test = new boolean[10];
    ~~~
    boolean类型的数组初始化的值全为false

- int 类型的数组
    ~~~java
    int[] test = new int[10];
    ~~~
    int类型的数组初始化的值全为0